[{"authors":["Dayeol Lee","Dmitrii Kuvaiskii","Anjo Vahldiek-Oberwagner","Mona Vij"],"categories":null,"content":"","date":1599688800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"a10b66f22373fc3a2dc3e8d62f1e654f","permalink":"https://vahldiek.github.io/publication/lee-2020-ppml/","publishdate":"2020-09-10T00:00:00+02:00","relpermalink":"/publication/lee-2020-ppml/","section":"publication","summary":"We present a practical framework to deploy privacy-preserving machine learning (PPML) applications in untrusted clouds based on a trusted execution environment (TEE). Specifically, we shield unmodified PyTorch ML applications by running them in Intel SGX enclaves with encrypted model parameters and encrypted input data to protect the confidentiality and integrity of these secrets at rest and during runtime. We use the open-source Graphene library OS with transparent file encryption and SGX-based remote attestation to minimize porting effort and seamlessly provide file protection and attestation. Our approach is completely transparent to the machine learning application: the developer and the end-user do not need to modify the ML application in any way.","tags":null,"title":"Privacy-Preserving Machine Learning in Untrusted Clouds Made Simple","type":"publication"},{"authors":["Anjo Vahldiek-Oberwagner","Chia-Che Tsai","Dmitrii Kuvaiskii","Don Porter"],"categories":null,"content":"","date":1599688800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599758228,"objectID":"c10e63151000023863e5b0910a32c99a","permalink":"https://vahldiek.github.io/publication/vahldiek-oberwagner-2020-secdev/","publishdate":"2020-09-10T00:00:00+02:00","relpermalink":"/publication/vahldiek-oberwagner-2020-secdev/","section":"publication","summary":"In this tutorial, we will walk through the steps of using the Graphene framework to establish a confidential computing environment for protecting the data of an unmodified Linux application on untrusted hosts. Graphene is an open-source project since 2014 and has been ported for Intel SGX, an innovative CPU feature design for confidential computing. Graphene has been maintained by the community and has been actively adopted for prototyping and development. This tutorial will start with an introduction and overview of the Graphene project and architecture, followed by the step-by-step guide for installing, configuring, executing, and debugging the Graphene framework for confidential computing of applications. In particular, this tutorial will deep dive into several latest features of Graphene, including remote attestation, protected FS, Graphene shielded containers.","tags":null,"title":"Tutorial: Graphene: Confidential Computing for Unmodified Linux Applications","type":"publication"},{"authors":["Anjo Vahldiek-Oberwagner","Dmitrii Kuvaiskii"],"categories":null,"content":"","date":1593640800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1600383457,"objectID":"fc7580379ee37415bcea2efb6ae984e0","permalink":"https://vahldiek.github.io/publication/vahldiek-2020-lss/","publishdate":"2020-07-02T00:00:00+02:00","relpermalink":"/publication/vahldiek-2020-lss/","section":"publication","summary":"Computing on secret data is challenging with today’s cloud service provider (CSP)\r\nofferings. CSP have full visibility into their client’s workloads and data while run in a VM or\r\ncontainer and shielding against other tenants. On the contrary, confidential computing (CC)\r\ntechniques (e.g., Intel Software Guard Extension (SGX)) offer a reverse sandbox. These techniques\r\nshield the workload and data from accesses by the underlying system software (e.g., OS or VMM) and\r\nhardware attacks. Thus, preventing CSPs from accessing secrets. In addition, CC provides remote\r\nattestation to verify the integrity of applications.\r\n\r\nIn this talk we will present Graphene Secure Containers, a technique to automatically wrap an\r\nunmodified Linux application packaged in a container image to execute inside Intel SGX using the\r\nGraphene LibraryOS and allow users to verify application integrity via remote attestation. ","tags":null,"title":"Automatically Securing Linux Application Containers in Untrusted Clouds","type":"publication"},{"authors":["Anjo Vahldiek-Oberwagner","Eslam Elnikety","Nuno O. Duarte","Michael Sammler","Peter Druschel","Deepak Garg"],"categories":null,"content":"","date":1547420400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"e35baa3c4ce5ea8876db20f423926be5","permalink":"https://vahldiek.github.io/publication/vahldiek-2018-erim/","publishdate":"2019-01-14T00:00:00+01:00","relpermalink":"/publication/vahldiek-2018-erim/","section":"publication","summary":"Isolating sensitive data and state can increase the security and robustness of many applications. Examples include protecting cryptographic keys against exploits like OpenSSL's Heartbleed bug or protecting a language runtime from native libraries written in unsafe languages. When runtime references across isolation boundaries occur relatively infrequently, then page-based hardware isolation can be used, because the cost of kernel- or hypervisor-mediated domain switching is tolerable. However, some applications, such as the isolation of cryptographic session keys in network-facing services, require very frequent domain switching. In such applications, the overhead of kernel- or hypervisor-mediated domain switching is prohibitive. In this paper, we present ERIM, a novel technique that provides hardware-enforced isolation with low overhead on x86 CPUs, even at high switching rates (ERIM's measured overhead is less than 1% for 100,000 switches per second). The key idea is to combine protection keys (MPKs), a feature recently added to x86 that allows protection domain switches in userspace, with binary inspection to prevent circumvention. We show that ERIM can be applied with little effort to new and existing applications, doesn't require compiler changes, can run on a stock Linux kernel, and has low runtime overhead even at high domain switching rates. ","tags":null,"title":"ERIM: Secure, Efficient In-Process Isolation with Memory Protection Keys","type":"publication"},{"authors":null,"categories":null,"content":"In today’s systems, policies protecting stored data and mechanisms for their enforcement are spread across many software components, increasing the risk of violation due to bugs, vulnerabilities and misconfigurations. We suggest Guardat to addresses this problem. Users, developers and administrators specify file protection policies declaratively, concisely and separate from code, and Guardat enforces these policies by mediating I/O in the storage layer. Thus, policy enforcement relies only on the integrity of the Guardat controller and any external policy dependencies. The semantic gap between the storage layer enforcement and per-file policies is bridged using cryptographic attestations from Guardat. We show experimentally that the overhead is low.\n","date":1544829887,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545152683,"objectID":"8c9785daf6f9b03e3a33f7f19964372a","permalink":"https://vahldiek.github.io/project/guardat/","publishdate":"2018-12-15T00:24:47+01:00","relpermalink":"/project/guardat/","section":"project","summary":"Enforcing security policies at the storage layer to reduce attack surface of existing solutions.","tags":["secure storage"],"title":"Protecting Persistent Data","type":"project"},{"authors":null,"categories":null,"content":"Isolating sensitive data and state can increase the security and robustness of many applications. Applications, such as isolating cryptographic session keys in a network-facing application or isolating frequently invoked native libraries in managed runtimes, require very frequent domain switching. In such applications, the overhead of kernel- or hypervisormediated domain switching is prohibitive. We suggest ERIM, a novel technique, that provides hardware-enforced isolation with low overhead, even at high switching rates (ERIM\u0026rsquo;s average overhead is less than 1% for 100,000 switches per second). The key idea is to combine memory protection keys (MPKs), a feature recently added to Intel CPUs that allows protection domain switches in userspace, with binary inspection to prevent circumvention. We show that ERIM can be applied with little effort to new and existing applications, doesn\u0026rsquo;t require compiler changes and can run on a stock Linux kernel.\n","date":1544829882,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545152683,"objectID":"373b4159e343df7487c10b9166fe892e","permalink":"https://vahldiek.github.io/project/erim/","publishdate":"2018-12-15T00:24:42+01:00","relpermalink":"/project/erim/","section":"project","summary":"Providing isolation for sensitive data and state to increase the security and robustness of applications. ","tags":["memory isolation","Intel MPK"],"title":"Secure, Efficient In-Process Memory Isolation","type":"project"},{"authors":null,"categories":null,"content":"Computing on secret data is challenging with today’s cloud service provider (CSP) offerings. CSP have full visibility into their client’s workloads and data while run in a VM or container and shielding against other tenants. On the contrary, confidential computing (CC) techniques (e.g., Intel Software Guard Extension (SGX)) offer a reverse sandbox. These techniques shield the workload and data from accesses by the underlying system software (e.g., OS or VMM) and hardware attacks. Thus, preventing CSPs from accessing secrets. In addition, CC provides remote attestation to verify the integrity of applications.\nProjects in this space focus on popular cloud deployment scenarios and automate the process to deploy applications in confidential compute enclaves.\n","date":1544829882,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544829882,"objectID":"4a35e6f1dd3868e0f7687adce1962546","permalink":"https://vahldiek.github.io/project/untrusted-cloud/","publishdate":"2018-12-15T00:24:42+01:00","relpermalink":"/project/untrusted-cloud/","section":"project","summary":"Lift and shift unmodified applications into Intel SGX enclaves to shield them in an untrusted cloud. ","tags":["Intel SGX","Confidential Compute"],"title":"Shielding Applications in an untrusted Cloud","type":"project"},{"authors":["Anjo Lucas Vahldiek-Oberwagner"],"categories":null,"content":"","date":1538344800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"294b81c2f472d25ada7c4dc3d6d08969","permalink":"https://vahldiek.github.io/publication/vahldiek-2018-thesis/","publishdate":"2018-10-01T00:00:00+02:00","relpermalink":"/publication/vahldiek-2018-thesis/","section":"publication","summary":"Today computers store and analyze valuable and sensitive data. As a result we need to protect this data against confidentiality and integrity violations that can result in the illicit release, loss, or modification of a user’s and an organization’s sensitive data such as personal media content or client records. Existing techniques protecting confidentiality and integrity lack either efficiency or are vulnerable to malicious attacks. In this thesis we suggest techniques, Guardat and ERIM, to efficiently and robustly protect persistent and in-memory data. To protect the confidentiality and integrity of persistent data, clients specify per-file policies to Guardat declaratively, concisely and separately from code. Guardat enforces policies by mediating I/O in the storage layer. In contrast to prior techniques, we protect against accidental or malicious circumvention of higher software layers. We present the design and prototype implementation, and demonstrate that Guardat efficiently enforces example policies in a web server. To protect the confidentiality and integrity of in-memory data, ERIM isolates sensitive data using Intel Memory Protection Keys (MPK), a recent x86 extension to partition the address space. However, MPK does not protect against malicious attacks by itself. We prevent malicious attacks by combining MPK with call gates to trusted entry points and ahead-of-time binary inspection. In contrast to existing techniques, ERIM efficiently protects frequently-used session keys of web servers, an in-memory reference monitor’s private state, and managed runtimes from native libraries. These use cases result in high switch rates of the order of 10^5 - 10^6 switches/s. Our experiments demonstrate less then 1% runtime overhead per 100,000 switches/s, thus outperforming existing techniques.","tags":null,"title":"Techniques to Protect Confidentiality and Integrity of Persistent and In-Memory Data","type":"publication"},{"authors":["Robert Krahn","Bohdan Trach","Anjo Vahldiek-Oberwagner","Thomas Knauth","Pramod Bhatotia","Christof Fetzer"],"categories":null,"content":"","date":1522533600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593976397,"objectID":"b55e7fdf07cf827953d3c97470069b53","permalink":"https://vahldiek.github.io/publication/krahn-2018/","publishdate":"2018-04-01T00:00:00+02:00","relpermalink":"/publication/krahn-2018/","section":"publication","summary":"Third-party storage services pose the risk of integrity and confidentiality violations as the current storage policy enforcement mechanisms are spread across many layers in the system\r\nstack. To mitigate these security vulnerabilities, we present\r\nthe design and implementation of Pesos, a Policy Enhanced\r\nSecure Object Store (Pesos) for untrusted third-party storage\r\nproviders. Pesos allows clients to specify per-object security\r\npolicies, concisely and separately from the storage stack, and\r\nenforces these policies by securely mediating the I/O in the\r\npersistence layer through a single unified enforcement layer.\r\nMore broadly, Pesos exposes a rich set of storage policies\r\nensuring the integrity, confidentiality, and access accounting\r\nfor data storage through a declarative policy language.\r\nPesos enforces these policies on untrusted commodity platforms by leveraging a combination of two trusted computing technologies: Intel SGX for trusted execution environment (TEE) and Kinetic Open Storage for trusted storage. We\r\nhave implemented Pesos as a fully-functional storage system\r\nsupporting many useful end-to-end storage features, and a\r\nrange of effective performance optimizations. We evaluated\r\nPesos using a range of micro-benchmarks, and real-world\r\nuse cases. Our evaluation shows that Pesos incurs reasonable\r\nperformance overheads for the enforcement of policies while\r\nkeeping the trusted computing base (TCB) small.","tags":null,"title":"Pesos: Policy Enhanced Secure Object store","type":"publication"},{"authors":["James Litton","Anjo Vahldiek-Oberwagner","Eslam Elnikety","Deepak Garg","Bobby Bhattacharjee","Peter Druschel"],"categories":null,"content":"","date":1475272800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593976397,"objectID":"e2a4f4684285c614cafe7ef69d5df8a7","permalink":"https://vahldiek.github.io/publication/litton-2016/","publishdate":"2016-10-01T00:00:00+02:00","relpermalink":"/publication/litton-2016/","section":"publication","summary":"We introduce a new OS abstraction—light-weight con- texts (lwCs)—that provides independent units of protec- tion, privilege, and execution state within a process. A process may include several lwCs, each with possibly different views of memory, file descriptors, and access capabilities. lwCs can be used to efficiently implement roll-back (process can return to a prior recorded state), isolated address spaces (lwCs within the process may have different views of memory, e.g., isolating sensitive data from network-facing components or isolating differ- ent user sessions), and privilege separation (in-process reference monitors can arbitrate and control access). lwCs can be implemented efficiently: the overhead of a lwC is proportional to the amount of memory exclu- sive to the lwC; switching lwCs is quicker than switching kernel threads within the same process. We describe the lwC abstraction and API, and an implementation of lwCs within the FreeBSD 11.0 kernel. Finally, we present an evaluation of common usage patterns, including fast roll- back, session isolation, sensitive data isolation, and in- process reference monitoring, using Apache, nginx, PHP, and OpenSSL.","tags":["Max Planck Institute for Software Systems","University of Maryland"],"title":"Light-Weight Contexts: An OS Abstraction for Safety and Performance","type":"publication"},{"authors":["Eslam Elnikety","Aastha Mehta","Anjo Vahldiek-oberwagner","Deepak Garg","Peter Druschel"],"categories":null,"content":"","date":1451602800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593976397,"objectID":"3debed590ff91e91279afca1ba079561","permalink":"https://vahldiek.github.io/publication/elnikety-2016/","publishdate":"2016-01-01T00:00:00+01:00","relpermalink":"/publication/elnikety-2016/","section":"publication","summary":"Data retrieval systems process data from many sources, each subject to its own data use policy. Ensuring compli-ance with these policies despite bugs, misconfiguration, or operator error in a large, complex, and fast evolving system is a major challenge. Thoth provides an effi-cient, kernel-level compliance layer for data use policies. Declarative policies are attached to the systems' input and output files, key-value tuples, and network connec-tions, and specify the data's integrity and confidential-ity requirements. Thoth tracks the flow of data through the system, and enforces policy regardless of bugs, mis-configurations, compromises in application code, or ac-tions by unprivileged operators. Thoth requires minimal changes to an existing system and has modest overhead, as we show using a prototype Thoth-enabled data re-trieval system based on the popular Apache Lucene.","tags":null,"title":"Thoth : Comprehensive Policy Compliance in Data Retrieval Systems","type":"publication"},{"authors":["Anjo Vahldiek-Oberwagner","Eslam Elnikety","Aastha Mehta","Deepak Garg","Peter Druschel","Rodrigo Rodrigues","Johannes Gehrke","Ansley Post"],"categories":null,"content":"","date":1429221600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"b47edddac9be84810077adc48a060580","permalink":"https://vahldiek.github.io/publication/vahldiek-oberwagner-2015/","publishdate":"2015-04-17T00:00:00+02:00","relpermalink":"/publication/vahldiek-oberwagner-2015/","section":"publication","summary":"In today’s data processing systems, both the policies protecting stored data and the mechanisms for their enforcement are spread over many software components and configuration files, increasing the risk of policy violation due to bugs, vulnerabilities and misconfigurations. Guardat addresses this problem. Users, developers and administrators specify file protection policies declaratively, concisely and separate from code, and Guardat enforces these policies by mediating I/O in the storage layer. Policy enforcement relies only on the integrity of the Guardat controller and any external policy dependencies. The semantic gap between the storage layer enforcement and per-file policies is bridged using cryptographic attestations from Guardat. We present the design and prototype implementation of Guardat, enforce example policies in a Web server, and show experimentally thatits overhead is low.","tags":null,"title":"Guardat: Enforcing data policies at the storage layer","type":"publication"},{"authors":["Anjo Vahldiek","Eslam Elnikety","Ansley Post","Peter Druschel","Rodrigo Rodrigues"],"categories":null,"content":"","date":1312149600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"324687ddd9b814e7fe809d29cd7bb411","permalink":"https://vahldiek.github.io/publication/vahldiek-2011/","publishdate":"2011-08-01T00:00:00+02:00","relpermalink":"/publication/vahldiek-2011/","section":"publication","summary":"We present a storage primitive called a storage lease. Data stored under a lease cannot be written for a pre-determined period. During the lease period, online data is protected from corruption due to security breaches, software errors, or accidental data deletion. Storage leases fill an important gap in the spectrum of data protection options because they combine strong integrity for online data with the ability to eventually reclaim storage. We define the storage lease primitive, show how it can be implemented in storage device firmware, and discuss its applications. A simulation-based evaluation indicates that storage leases have a modest performance cost for most workloads on magnetic disks. Using a small amount of flash memory, this overhead can be reduced to near zero.","tags":null,"title":"Protecting Data Integrity with Storage Leases","type":"publication"},{"authors":["Hernán Baró Graf","Holger Hermanns","Juhi Kulshrestha","Jens Peter","Anjo Vahldiek","Aravind Vasudevan"],"categories":null,"content":"","date":1293836400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599759167,"objectID":"282e55345bf12f722b9f7d036e1624b8","permalink":"https://vahldiek.github.io/publication/graf-2011-verifiedwireless/","publishdate":"2011-01-01T00:00:00+01:00","relpermalink":"/publication/graf-2011-verifiedwireless/","section":"publication","summary":"Wireless communication, hard real time requirements and safety criticality do not go together well. This paper reports on the modelling, design, simulation, implementation and deployment of a small exemplary case that possesses all these features. State-of-the-art verification and simulation means are employed to ensure its proper operation.","tags":null,"title":"A verifiedwireless safety critical hard real-time design","type":"publication"}]